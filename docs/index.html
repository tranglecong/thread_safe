<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRLC ThreadSafe: Thread Safe</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TRLC ThreadSafe
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">@Trang Le - [trangs.leecoong@gmail.com]</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Thread Safe </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> The <b>Thread Safe Library</b> is a C++ library that provides utilities for managing thread-safe operations. This library is designed to simplify concurrent programming by offering easy-to-use and robust thread-safe abstractions.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Features</h1>
<ul>
<li><b>Queue</b>: A thread-safe queue with the ability to control pop and push operations, along with policies for discarding elements (oldest, newest, or no discard).</li>
<li><b>Variable</b>: A thread-safe variable manager, ensuring safe reads and writes across multiple threads.</li>
<li><b>Thread</b>: A thread manager that supports once mode and loop mode, can check results using callbacks and includes some other features.</li>
<li><b>Wait</b>: A mechanism to safely handle thread waiting and signaling.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Example Code</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Queue</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;cstdlib&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;ostream&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;trlc/threadsafe/queue.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using Queue = trlc::threadsafe::Queue&lt;int&gt;;</div>
<div class="line">    // Queue settings: size = 3, discard oldest elements when full, full control over push/pop</div>
<div class="line">    Queue::Settings settings;</div>
<div class="line">    settings.size = 3;</div>
<div class="line">    settings.discard = Queue::Discard::DISCARD_OLDEST;</div>
<div class="line">    settings.control = Queue::Control::FULL_CONTROL;</div>
<div class="line"> </div>
<div class="line">    // Create the thread-safe queue with the given settings</div>
<div class="line">    Queue queue(settings);</div>
<div class="line">    // Set a callback to be called when an element is discarded</div>
<div class="line">    queue.setDiscardedCallback(</div>
<div class="line">        [](const int&amp; discardedElem)</div>
<div class="line">        { std::cout &lt;&lt; &quot;Discarded element: &quot; &lt;&lt; discardedElem &lt;&lt; std::endl; });</div>
<div class="line"> </div>
<div class="line">    std::atomic&lt;bool&gt; running{true};</div>
<div class="line">    std::thread consumerThread{</div>
<div class="line">        [&amp;]() -&gt; void</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; &quot;[Consumer]: Waiting queue to open for pop.&quot; &lt;&lt; std::endl;</div>
<div class="line">            if (!queue.waitPopOpen())</div>
<div class="line">            {</div>
<div class="line">                std::cerr &lt;&lt; &quot;[Consumer]: Failed to wait pop open!&quot; &lt;&lt; std::endl;</div>
<div class="line">                return;</div>
<div class="line">            }</div>
<div class="line">            std::cout &lt;&lt; &quot;[Consumer]: The queue has opened for pop.&quot; &lt;&lt; std::endl;</div>
<div class="line">            while (running)</div>
<div class="line">            {</div>
<div class="line">                int elem{};</div>
<div class="line">                if (!queue.pop(elem))</div>
<div class="line">                {</div>
<div class="line">                    continue;</div>
<div class="line">                }</div>
<div class="line">                std::cout &lt;&lt; &quot;[Consumer]: &quot; &lt;&lt; elem &lt;&lt; std::endl;</div>
<div class="line">            };</div>
<div class="line">        }};</div>
<div class="line">    // Push elements into the queue</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds{100});</div>
<div class="line">    std::cout &lt;&lt; &quot;Pushing elements into the queue...&quot; &lt;&lt; std::endl;</div>
<div class="line">    queue.openPush();</div>
<div class="line">    queue.push(1);</div>
<div class="line">    queue.push(2);</div>
<div class="line">    queue.push(3); // Queue is now full</div>
<div class="line">    // Try to push another element, this should discard the oldest (1)</div>
<div class="line">    queue.push(4); // Oldest element (1) will be discarded</div>
<div class="line">    queue.openPop();</div>
<div class="line">    queue.closePush();</div>
<div class="line">    queue.push(5); // Will not push due to push closed</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds{100});</div>
<div class="line"> </div>
<div class="line">    // Push more elements</div>
<div class="line">    queue.openPush();</div>
<div class="line">    queue.push(6);</div>
<div class="line">    queue.push(7);</div>
<div class="line">    queue.push(8);</div>
<div class="line">    queue.openPop();</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds{100});</div>
<div class="line">    running = false;</div>
<div class="line">    queue.closePush();</div>
<div class="line">    queue.closePop();</div>
<div class="line">    consumerThread.join();</div>
<div class="line"> </div>
<div class="line">    return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Thread</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;trlc/threadsafe/thread.hpp&gt;</div>
<div class="line"> </div>
<div class="line">void print(const std::string msg)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int addTask(int a, int b)</div>
<div class="line">{</div>
<div class="line">    return a + b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::string countTask(int start)</div>
<div class="line">{</div>
<div class="line">    static int count{start};</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    return std::string{&quot;count = &quot;} + std::string{std::to_string(count++)};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Helper function to simulate work by sleeping</div>
<div class="line">void simulateWork(int duration_ms)</div>
<div class="line">{</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(duration_ms));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using Thread = trlc::threadsafe::Thread;</div>
<div class="line"> </div>
<div class="line">    // Example 1: Run the task once</div>
<div class="line">    std::cout &lt;&lt; &quot;Example 1: Run the task once&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    Thread thread_once{&quot;thread once&quot;};</div>
<div class="line">    thread_once.setStartCallback([]() -&gt; void</div>
<div class="line">                                 { std::cout &lt;&lt; &quot;Thread started...&quot; &lt;&lt; std::endl; });</div>
<div class="line">    thread_once.setResultCallback([](const Thread::ResultType&amp; result) -&gt; void</div>
<div class="line">                                  { std::cout &lt;&lt; &quot;Result callback called! &quot; &lt;&lt; std::endl; });</div>
<div class="line">    thread_once.setExitCallback([]() -&gt; void</div>
<div class="line">                                { std::cout &lt;&lt; &quot;Thread finished.&quot; &lt;&lt; std::endl; });</div>
<div class="line">    // Invoke task for thread</div>
<div class="line">    thread_once.invoke(print, &quot;Hello World&quot;);</div>
<div class="line">    thread_once.run(Thread::RunMode::ONCE);</div>
<div class="line">    // Wait for the thread to finish</div>
<div class="line">    thread_once.stop();</div>
<div class="line"> </div>
<div class="line">    // Invoke task for thread</div>
<div class="line">    thread_once.invoke(print, &quot;From Thread&lt;&gt;&quot;);</div>
<div class="line">    thread_once.run(Thread::RunMode::ONCE);</div>
<div class="line">    // Wait for the thread to finish</div>
<div class="line">    thread_once.stop();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    // Example 2: Run a task in a loop until stopped</div>
<div class="line">    std::cout &lt;&lt; &quot;Example 2: Run the task in a loop&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    Thread looping_thread{&quot;looping thread&quot;};</div>
<div class="line">    looping_thread.setStartCallback([]() -&gt; void</div>
<div class="line">                                    { std::cout &lt;&lt; &quot;Looping thread started...&quot; &lt;&lt; std::endl; });</div>
<div class="line">    looping_thread.setResultCallback([](const Thread::ResultType&amp; result) -&gt; void</div>
<div class="line">                                     { std::cout &lt;&lt; &quot;Loop result: &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(result) &lt;&lt; std::endl; });</div>
<div class="line">    looping_thread.setExitCallback([]() -&gt; void</div>
<div class="line">                                   { std::cout &lt;&lt; &quot;Looping thread finished.&quot; &lt;&lt; std::endl; });</div>
<div class="line"> </div>
<div class="line">    looping_thread.invoke(countTask, 10);</div>
<div class="line">    looping_thread.run(Thread::RunMode::LOOP);</div>
<div class="line"> </div>
<div class="line">    // Simulate some work in the main thread while the loop runs</div>
<div class="line">    simulateWork(1050);</div>
<div class="line">    looping_thread.stop();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    // Example 3: Running a predicate-controlled loop</div>
<div class="line">    std::cout &lt;&lt; &quot;Example 3: Loop with a predicate (runs 5 times)&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    int iteration_count = 0;</div>
<div class="line">    Thread pred_thread{&quot;PredicateThread&quot;};</div>
<div class="line">    // Set result callback to print results and increment the count</div>
<div class="line">    pred_thread.setResultCallback([&amp;iteration_count](const Thread::ResultType&amp; result) -&gt; void</div>
<div class="line">                                  {</div>
<div class="line">        std::cout &lt;&lt; &quot;Predicate loop result: &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(result) &lt;&lt; std::endl;</div>
<div class="line">        iteration_count++; });</div>
<div class="line"> </div>
<div class="line">    pred_thread.invoke(countTask, 10);</div>
<div class="line">    // Set predicate</div>
<div class="line">    pred_thread.setPredicate([&amp;iteration_count]() -&gt; bool</div>
<div class="line">                             {</div>
<div class="line">            return iteration_count &lt; 5;  /*Stop after 5 iterations*/ });</div>
<div class="line"> </div>
<div class="line">    pred_thread.run(Thread::RunMode::LOOP);</div>
<div class="line">    // Simulate some work in the main thread while the loop runs</div>
<div class="line">    simulateWork(1000);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Predicate-controlled loop completed.&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Variable</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;atomic&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;cstdlib&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;ostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;trlc/threadsafe/variable.hpp&gt;</div>
<div class="line"> </div>
<div class="line">// Helper function to simulate work by sleeping</div>
<div class="line">void simulateWork(int duration_ms)</div>
<div class="line">{</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(duration_ms));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using Variable = trlc::threadsafe::Variable&lt;std::string&gt;;</div>
<div class="line"> </div>
<div class="line">    Variable var{&quot;Initial&quot;};</div>
<div class="line">    std::atomic&lt;bool&gt; running{true};</div>
<div class="line"> </div>
<div class="line">    // Reading and print out value</div>
<div class="line">    std::thread readingThread{[&amp;]() -&gt; void</div>
<div class="line">                              {</div>
<div class="line">                                  static std::string previous_value{};</div>
<div class="line">                                  while (running)</div>
<div class="line">                                  {</div>
<div class="line">                                      if (var != previous_value)</div>
<div class="line">                                      {</div>
<div class="line">                                          previous_value = var;</div>
<div class="line">                                          std::cout &lt;&lt; &quot;Current value: &quot; &lt;&lt; var.get() &lt;&lt; std::endl;</div>
<div class="line">                                      }</div>
<div class="line">                                      std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">                                  };</div>
<div class="line">                              }};</div>
<div class="line">    // Change value by assignment operator</div>
<div class="line">    simulateWork(10);</div>
<div class="line">    var = &quot;0&quot;;</div>
<div class="line">    simulateWork(10);</div>
<div class="line">    // Use invoke to call member function</div>
<div class="line">    var.invoke([](Variable::Type&amp; s)</div>
<div class="line">               { s.append(&quot;1&quot;); });</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Current size: &quot; &lt;&lt; var.invoke([](const Variable::Type&amp; s)</div>
<div class="line">                                                { return s.size(); })</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    simulateWork(10);</div>
<div class="line">    // Use comparison operator</div>
<div class="line">    var = &quot;Example&quot;;</div>
<div class="line">    std::cout &lt;&lt; (var == &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (var != &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (var &gt;= &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (var &lt;= &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (var &gt; &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; (var &lt; &quot;Example&quot;) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">    running = false;</div>
<div class="line">    readingThread.join();</div>
<div class="line"> </div>
<div class="line">    return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Wait</h2>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;atomic&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;trlc/threadsafe/wait.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using Wait = trlc::threadsafe::Wait;</div>
<div class="line">    Wait wait;</div>
<div class="line">    // Thread 1: Will Timeout</div>
<div class="line">    std::thread t1([&amp;]()</div>
<div class="line">                   {</div>
<div class="line">        std::cout &lt;&lt; &quot;[Thread 1]: Waiting for signal...&quot; &lt;&lt; std::endl;</div>
<div class="line">        if (Wait::Status::TIMEOUT == wait.waitFor(std::chrono::milliseconds{100}))</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; &quot;[Thread 1]: Timeout!&quot; &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; &quot;[Thread 1]: Leave!&quot; &lt;&lt; std::endl; });</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">    // Thread 2: Wait Predicate</div>
<div class="line">    std::atomic&lt;bool&gt; pred_flag{false};</div>
<div class="line">    auto pred = [&amp;pred_flag]() -&gt; bool</div>
<div class="line">    { return pred_flag; };</div>
<div class="line">    std::thread t2([&amp;]()</div>
<div class="line">                   {</div>
<div class="line">    std::cout &lt;&lt; &quot;[Thread 2]: Waiting for predicate...&quot; &lt;&lt; std::endl;</div>
<div class="line">    if (Wait::Status::SUCCESS == wait.wait(pred))</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; &quot;[Thread 2]: Predicate!&quot; &lt;&lt; std::endl;</div>
<div class="line">    } </div>
<div class="line">    std::cout &lt;&lt; &quot;[Thread 2]: Leave!&quot; &lt;&lt; std::endl; });</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">    // Thread 3: Will Timeout</div>
<div class="line">    std::thread t3([&amp;]()</div>
<div class="line">                   {</div>
<div class="line">    std::cout &lt;&lt; &quot;[Thread 3]: Waiting for predicate...&quot; &lt;&lt; std::endl;</div>
<div class="line">    if (Wait::Status::TIMEOUT == wait.waitFor(std::chrono::milliseconds{200}, []()-&gt;bool{return false;}))</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; &quot;[Thread 3]: Timeout!&quot; &lt;&lt; std::endl;</div>
<div class="line">    } </div>
<div class="line">    std::cout &lt;&lt; &quot;[Thread 3]: Leave!&quot; &lt;&lt; std::endl; });</div>
<div class="line"> </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(300));</div>
<div class="line">    pred_flag = true;</div>
<div class="line">    wait.notify();</div>
<div class="line">    t1.join();</div>
<div class="line">    t2.join();</div>
<div class="line">    t3.join();</div>
<div class="line"> </div>
<div class="line">    return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Prerequisites</h2>
<p>To use this library, you need:</p>
<ul>
<li><b>CMake</b> 3.15 or higher</li>
<li><b>GCC</b>, <b>Clang</b> or <b>MSVC</b> compiler with C++17 support</li>
<li><b>GoogleTest</b> (automatically fetched by CMake for testing)</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Integration</h2>
<h3><a class="anchor" id="autotoc_md10"></a>
Subdirectory</h3>
<p>This library can be used as CMake subdirectory.</p>
<ol type="1">
<li>Fetch it, e.g. using [git submodules]:</li>
</ol>
<div class="fragment"><div class="line">git submodule add https://github.com/tranglecong/trlc_threadsafe</div>
<div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>Or you can use git clone: <code>git clone <a href="https://github.com/tranglecong/trlc_threadsafe.git">https://github.com/tranglecong/trlc_threadsafe.git</a></code></p>
<ol type="1">
<li>Call <code>add_subdirectory(path_to/trlc_threadsafe)</code> or whatever your local path is to make it available in CMake file.</li>
<li>Simply call <code>target_link_libraries(your_target PUBLIC trlc::threadsafe)</code> to link this library and setups the include search path and compilation options.</li>
</ol>
<h3><a class="anchor" id="autotoc_md11"></a>
Install Library</h3>
<p>You can also install trlc_threadsafe library</p>
<ol type="1">
<li><p class="startli">Run CMake configure inside the library sources. If you want to build the UT and example set <code>-DTRLC_BUILD_TESTS=ON</code> , <code>-DTRLC_BUILD_EXAMPLES=ON</code></p>
<p class="startli">```bash cmake -DCMAKE_BUILD_TYPE=Debug -DTRLC_BUILD_TESTS=OFF -DTRLC_BUILD_EXAMPLES=OFF -S . -B ./build ```</p>
</li>
<li><p class="startli">Build and install the library under <code>${CMAKE_INSTALL_PREFIX}</code>. You may be required to have sudo privileges to install in the <code>/usr/*</code>.</p>
<p class="startli">```bash cmake &ndash;build ./build -j8 &ndash; install ```</p>
<p class="startli">[Optional] if you want to run UT.</p>
<p class="startli">```bash ctest &ndash;test-dir ./build ```</p>
</li>
<li><p class="startli">To use an installed library.</p>
<p class="startli">```cmake find_package(trlc REQUIRED) target_link_libraries(your_target PUBLIC trlc::threadsafe) ```</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md12"></a>
Documentation</h1>
<p>Full documentation can be found at <a href="https://tranglecong.github.io/trlc_threadsafe/html">https://tranglecong.github.io/trlc_threadsafe/html</a>.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Contributing</h1>
<p>Welcome contributions from everyone! If youâ€™d like to help improve this project. Thank you for considering contributing to this project! </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
